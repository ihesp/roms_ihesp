#!/usr/bin/env python3

"""ROMS namelist creator
"""

# Typically ignore this.
# pylint: disable=invalid-name

# Disable these because this is our standard setup
# pylint: disable=wildcard-import,unused-wildcard-import,wrong-import-position

import os, sys

CIMEROOT = os.environ.get("CIMEROOT")
if CIMEROOT is None:
    raise SystemExit("ERROR: must set CIMEROOT environment variable")
sys.path.append(os.path.join(CIMEROOT, "scripts", "Tools"))

from standard_script_setup import *
from CIME.case import Case
from CIME.utils import expect, run_cmd, safe_copy
from CIME.buildnml import create_namelist_infile, parse_input
from CIME.nmlgen import NamelistGenerator
from math import sqrt

logger = logging.getLogger(__name__)

# pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements
####################################################################################
def _create_namelists(case, confdir, inst_string, infile, nmlgen, data_list_path):
####################################################################################
    """Write out the namelist for this component.

    Most arguments are the same as those for `NamelistGenerator`. The
    `inst_string` argument is used as a suffix to distinguish files for
    different instances. The `confdir` argument is used to specify the directory
    in which output files will be placed.
    """
    #----------------------------------------------------
    # Create config dictionary
    #----------------------------------------------------
    config = {}
    config['ocn_grid'] = case.get_value("OCN_GRID")
    nmlgen.init_defaults([infile], config)

    startdate = case.get_value("RUN_STARTDATE")
    starttod = case.get_value("START_TOD")
    startyear = int(startdate[0:4])
    startmon = int(startdate[5:7])
    startday = int(startdate[8:10])
    nmlgen.set_value("start_year", startyear)
    nmlgen.set_value("start_month", startmon)
    nmlgen.set_value("start_day", startday)
    nmlgen.set_value("start_hour", int(starttod/3600))
    nmlgen.set_value("start_minute", int(starttod%3600/60))
    nmlgen.set_value("start_second", int(starttod%60))

    ntasks = case.get_value("OCN_NTASKS")
    ntilei, ntilej = _decomp2d(ntasks)

    nmlgen.set_value("ntilei", [ntilei])
    nmlgen.set_value("ntilej", [ntilej])
    #----------------------------------------------------
    # Write output files
    #----------------------------------------------------
    namelist_file = os.path.join(confdir, "ocn_in")
    #----------------------------------------------------
    # Standard fortran namelists
    #----------------------------------------------------
    nmlgen.write_output_file(namelist_file, data_list_path, groups=['ocn_io', 'ocn_timemgr'])

    #----------------------------------------------------
    # Non-Standard Roms name value pairs list
    #----------------------------------------------------

    namelist_file = os.path.join(confdir, "ocean.in")
    groups = list(nmlgen._namelist._groups.keys())
    # ocean.in requires some variables to be ordered, this is handled by seperating them into
    # groups ocean.in0, ocean.in1, ...
    groups.remove('ocn_io')
    groups.remove('ocn_timemgr')

    ntasks = case.get_value("OCN_NTASKS")
    
    nmlgen.write_output_file(namelist_file, data_list_path, groups=groups, format_="roms")

    # set rundir
    rundir = case.get_value("RUNDIR")

    # copy nuopc.runconfig to rundir
    safe_copy(os.path.join(confdir,"ocn_in"), rundir)
    safe_copy(os.path.join(confdir,"ocean.in"), rundir)


def _decomp2d(ntasks):
    i = int(sqrt(ntasks))
    while(i > 0):
        if ntasks/i == int(ntasks/i):
            return i,int(ntasks/i)
        i = i-1
    expect(FALSE,"Should never get here: ntasks={}".format(ntasks))

# pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements
###############################################################################
def buildnml(case, caseroot, compname):
###############################################################################
    """Build the roms namelist """

    # Build the component namelist
    if compname != "roms":
        raise AttributeError

    srcroot = case.get_value("SRCROOT")
    continue_run = case.get_value("CONTINUE_RUN")
    ninst = case.get_value("NINST_OCN")
    ocn_grid = case.get_value("OCN_GRID")  # BK: need a ocn grid var for roms

    rundir = case.get_value("RUNDIR")
    dinlocroot = case.get_value("DIN_LOC_ROOT")
    ntasks = case.get_value("NTASKS_OCN")
    srcmodsdir = os.path.join(caseroot,"SourceMods","src.roms")
    confdir = os.path.join(caseroot,"Buildconf","romsconf")

    for _dir in (confdir, rundir, srcmodsdir):
        if not os.path.isdir(_dir):
            os.makedirs(_dir)

    
    # assume the domain descript nc file is under dinlocroot/share/domains
    ddomain = os.path.join(dinlocroot,"share","domains")


    #----------------------------------------------------
    # Construct the namelist generator
    #----------------------------------------------------
    # Determine directory for user modified namelist_definitions.xml and namelist_defaults.xml
    user_xml_dir = os.path.join(caseroot, "SourceMods", "src.roms")
    expect(os.path.isdir(user_xml_dir),
           "user_xml_dir %s does not exist "%user_xml_dir)

    # NOTE: User definition *replaces* existing definition.
    namelist_xml_dir = os.path.join(srcroot, "components", "roms", "cime_config")
    definition_file = [os.path.join(namelist_xml_dir, "namelist_definition_roms.xml")]
    user_definition = os.path.join(user_xml_dir, "namelist_definition_roms.xml")
    if os.path.isfile(user_definition):
        definition_file = [user_definition]
    for file_ in definition_file:
        expect(os.path.isfile(file_), "Namelist XML file %s not found!" % file_)

    # Create the namelist generator object - independent of instance
    nmlgen = NamelistGenerator(case, definition_file)

    #----------------------------------------------------
    # Clear out old data.
    #----------------------------------------------------
    data_list_path = os.path.join(case.get_case_root(), "Buildconf", "roms.input_data_list")
    if os.path.exists(data_list_path):
        os.remove(data_list_path)

    #----------------------------------------------------
    # Loop over instances
    #----------------------------------------------------
    for inst_counter in range(1, ninst+1):

        # determine instance string
        inst_string = ""
        if ninst > 1:
            inst_string = '_' + '%04d' % inst_counter

        # create namelist_infile using user_nl_file as input
        user_nl_file = os.path.join(caseroot, "user_nl_roms" + inst_string)
        expect(os.path.isfile(user_nl_file),
               "Missing required user_nl_file %s " %(user_nl_file))
        namelist_infile = os.path.join(confdir, "namelist_infile")
        create_namelist_infile(case, user_nl_file, namelist_infile)

        # create namelist and stream file(s) data component
        _create_namelists(case, confdir, inst_string, namelist_infile, nmlgen, data_list_path)

        # ------------------------------------------------------------------------------
        # call build-namelist - output will go in caseroot/Buildconf/romsconf/ocn_in
        # ------------------------------------------------------------------------------
        # determine the directory containing build-namelist script
        # first check to see if build-namelist exists in SourceMods, if it exists use it
        bldnml_dir = os.path.join(srcroot,"components","roms","bld")

    safe_copy(os.path.join(srcroot,"components","roms","ROMS","External","varinfo.dat"), rundir)


###############################################################################
def _main_func():
    caseroot = parse_input(sys.argv)
    with Case(caseroot) as case:
        buildnml(case, caseroot, "roms")

if __name__ == "__main__":
    _main_func()
